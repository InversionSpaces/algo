\documentclass[a4paper,12pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amsbsy}
\usepackage{listings}
\begin{document}

\lstset{language=python}

\begin{enumerate}

\setcounter{enumi}{3}
\item б) Для начала, найдём предыдущий для $x$ в BST за $O(log(n))$: встаём в корень и действуем по следующему алгоритму. Пусть в вершине ключ $val$. Если $val < x$, то если значение в правом ребёнке $rval > x$ или его нет, то $val$ и есть предыдущий для $x$, иначе переходим в правого ребёнка. Если $val > x$, то преходим в левого ребёнка, а если его нет, то в BST нет предыдущего для $x$.

Теперь будем поддерживать односвязный список на вершинах BST. В каждой вершине будем хранить указатель на вершину со значением, следующим за данным значением. При вставке и удалении при помощи вышеописанной процедуры будем находить предыдущий и при помощи него соотвественно вставлять вершину в список или удалять её из него. (При удалении две вершины обмениваются значениями, при помощи нахождения предыдущего так же лёгко можно поправить указатели, указывающие на эти вершины).

Нахождение предыдущего не портить асимптотику вставки и удаления, а поддерживаемый список поможет нам выдавать следующий для вершины за $O(1)$.

\item Совершим DFS. Каждый его вызов будет возвращать путь максимального веса, начинающийся в данной вершине и не идущий обратно туда, откуда мы пришли. Он будет следовать такому алгоритму.
\begin{enumerate}
\item Вызовемся рекурсивно от всех соседей, кроме того, из которого пришли. Каждый сосед вернёт максимальный путь из себя, мы прибавим к нему ребро, ведущее из нас в него. Таким образом, переберём все максимальные пути, ведущие из нас. В процессе будем поддерживать два максимальных по весу пути из нас (Замечу, что это могут быть и нулевые пути). 
\item Сложим веса этих двух максимальных путей и получим новый путь. Обновим им глобальный ответ.
\item Вернём максимальный путь.
\end{enumerate}

Данный DFS запустим от любой вершины со значением предыдущей $-1$. Этот DFS побывает в каждой вершине ровно один раз и найдёт путь максимального веса такой, что в него входит эта вершина. Т.к. максимальный во всём дереве содержит вершину (может, одну, если он нулевой), мы его найдём.

\item Заведём сбалансированное BST, которое будем ассоциировать число с указателем на некое сбалансированное BST. Теперь будем так обрабатывать запросы.

\begin{enumerate}
\item Просят объединить множества с элементами $a_i$ и $a_j$. Ищем эти ключи в нашем дереве. 

Если оба там есть, то мы сливаем их деревья и каждому ключю присваеваем указатель на новове дерево.

Если одного ключа нет, то вставляем его в дерево второго и ассоциируем с ним указатель на это дерево.

Если обоих ключей нет, то создаём дерево, содержащее их двоих и ассоциируем с ними указатель на него.

\item Просят найти следующий для $x$ в множестве эелемента $a$. Ищем ключ $a$. 

Если его нет - создаём дерево, состаящее из него и ассоциируем с ним. 

Теперь он есть, а находить следующий мы научились в задаче 4.

В итоге на каждый запрос нам требуется $O(log(n))$ времени.
\end{enumerate}

\end{enumerate}

\end{document}