\documentclass[a4paper,12pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amsbsy}
\usepackage{listings}
\begin{document}

\lstset{language=python}

\begin{enumerate}

\item Пусть дано два AVL дерева $T_1$ и $T_2$, $keys(T_1) \leq keys(T_2)$. Пусть $h(T_1) \leq h(T_2)$. Тогда удалим максимум из $T_1$. При этом его высота может только уменьшится. Теперь спускаемся в дереве $T_2$ всегда налево, пока высота поддерева вершины не равна новой высоте $T_1$. Как только высота поддерева вершины $x$ равна высоте $T_1$, заменяем $x$ на удалённый максимум, как правое поддерево подвешиваем поддерево с корнем в $x$, а как левое - $T_1$. Далее проводим балансировку из вершины с максимумом.

Если же $h(T_1) \geq h(T_2)$, то проделываем алгоритм симметрично с минимумом в $T_2$.

Итого асимптотика - $O(log(|T_1|) + log(|T_2|))$. 

$log(|T_1|) + log(|T_2|) = log(|T_1||T_2|) \leq 2 \cdot log(max(|T_1|, |T_2|)) \leq 2 \cdot log(|T_1| + |T_2|)$

Поэтому это и $O(log(|T_1| + |T_2|)$

\setcounter{enumi}{5}
\item (Исправление: в прошлом решение не получится слить произвольные множества т.к. нет гарантий на ключи). 

Заведём set, который будет ассоциировать число с индексом в векторе, по которому будет лежать указатель на set. Теперь будем так обрабатывать запросы.

\begin{enumerate}
\item Просят объединить множества с элементами $a_i$ и $a_j$. Ищем эти ключи в нашем дереве. 

Если оба там есть, то мы сливаем их set по такому принципу: все элементы set меньшего размера вставляем в больший. В векторе же по нужным индексам кладём указатель на новый set.

Если одного ключа нет, то вставляем его в дерево второго и ассоциируем его с индексом второго.

Если обоих ключей нет, то создаём set, содержащий их двоих и вставляем его в конец вектора. Ассоциируем оба ключа с новым индексом.

\item Просят найти следующий для $x$ в множестве эелемента $a$. Ищем ключ $a$. 

Если его нет - создаём set, состаящий из ключа, вставляем его в конец вектора. Ассоциируем число с новым индексом.

Для нахождения следущего можно применить lower\_bound у set.

Заметим, что каждое число может быть переложено из set в set максимум $log(n)$ раз, т.к. при каждом перекладываении размер его set увеличивается как минимум вдвое. Одно перекладывание стоит $log(n)$. Заметим также, что при $q$ запросах может быть затронуто максимум $q \cdot 2$ элементов. Тогда итого асимптотика $O(q \cdot log(n))$

\item 

\end{enumerate}

\end{enumerate}

\end{document}